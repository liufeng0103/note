11 异常，日志，断言和调试所有的异常都是有Throwable继承而来的，下一层分解为2个分支:Error 和 Exception如果出现RuntimeException异常，那么一定是你的问题如果子类覆盖父类的一个方法，子类方法中声明的已检查异常不能超过父类方法中声明的异常范围习惯上，定义异常的类应该包含2个构造器，一个默认的构造器，另一个是带有详细描述信息的构造器捕获异常在调试基于图形界面的程序是，最好保证控制台窗口可见，并且没有被最小化e.getMessage()得到详细错误信息,或者使用e.getClass().getName()得到异常对象的实际类型将原始异常设置为新异常的“诱饵”catch(SQLException e){	Throwable se = new ServletException("database error");	se.initCause(e);	throw se;}当捕获异常时，用下面的语句重新得到原始异常Throwable e = se.getCause();断言assert 条件；assert 条件：表达式；断言运行测试期间向代码中插入一条检查语句，发布后这条插入语句将被自动移除启用和禁用断言java -enableassertions MyApp 或-ea来启动开启某个类或某个包java -ea:MyClass -ea:com.ibm.mylib... MyApp-da 禁用断言日志Logger.global 全局日志记录器Logger.global.info("File->Open menu item selected");取消所有日志Logger.global.serLevel(Level.OFF);高级日志Logger log = Logger.getLogger("com.ibm.myapp");7个级别SEVEREWARNINGINFOCONFIGFINEFINERFINEST设置级别log.setLevel(Level.FINE);log.warning("msg");log.fine("msg");